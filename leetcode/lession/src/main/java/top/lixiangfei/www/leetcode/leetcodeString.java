package top.lixiangfei.www.leetcode;

import java.util.ArrayList;
import java.util.List;

public class leetcodeString {

    public void test() {
//        String testString = "A man, a plan, a canal: Panama";
//        System.out.println(testString);
//        String result = reverseString(testString);
//        System.out.println(result);

//        int i = -2147483412;
////        int i = -2147483412;
//        System.out.println(i);
//        int ret = reverse(i);
//        System.out.println(ret);
//        String s = "loveleetcode";
//        String s = "cc";
//        String s = "z";
//        String s = "qiwjhweofwcupofoiieacqkeidxwuzdijnjbllkqgwmerdsgxqhgotijtvfbenrgfthmpjivojciclljrnxmsbwefrsrcohkxjdwfjirvpavxpbheqbmnetesusoqwounbvpndmglaneqwdippeqvgpqdnoagxnmiseqiprlaektvbkcmljadwbrwoghuxvtbtrqmusrttxfwafxklatitrfffrushoagfdidlnxoelpldngbbqjcwiwotaoixhlritgdesfjrolfcbqblssdpgmtptgooqvitjughstkikasfktscfpbwknctikvwtnfaekkuvckkmotlxbfwcggcnlfvkutvfthvvwbckbbwhgjfbsahqcrfhvtopucujpgtdsssrjxoahsdanueqarfhemoiaiducbcpfmnuqvicjaftkswcsqdnpqnuchsjeccaibqjajgdnkklriffhnxsoxlmsvigtishsqoqjnwdcxepdajsaiqgbrhpgmodrtmttjosjhilarbqpqsimjaajwsoqlvsndoftuhwcjolaxcffkaqtafbnoeqhcciprrvdrsnlkgsarpxwvsbvnaiojfwmrixqlnckjxxnbkblhqoiqbudqbwchfioqohhcbfjcglhaqhwrurwvnjusplljtnfxtqfxxnwnosbwbnthejvlohjbmornjfjwibiqvdtdbtmtulbrqvxcmwqpgplnvktnvksgmwicvxgxdiqpqwlcwpdkgqrhaccukedcexdttosseujjelkdvksdmwlvjfpuphjdufgplpveqatauncvsgltimrvcmqltkoqgsjnfsjfpepkhtoisearcierrghcxojlqdsuiqvwjhlbwwlvieaubkeqpuusuclldkdonrjnnkjtrwtctnewgdhkugfrpxlixpukeeolnnbkisfakplobkhxatujdejserlqfsdrxpjesdjawdnusjtxtmjrpsojrbkqidanualtbiqahjtqavekuasqkbinahacmoobmjoglsjkvadkvbiimqrivikoxcggttudwklnraufpjispscjluvqqijupscedlsfucbpttcixlpipdpfjlhataxpiiomvgrwukqwjdrntpsefcjewvoivbdxjesgrlawpjrjchmlmfahrxpprtciqknnmvntgdhnvqkipaqskmjhcdjulfdacmgxhuxbgfgtwpnuinxkemonbgqvvkciepvhdbabhsoijfstvhideogshpdaulwagkctqlbucrwepsaggnmfqcbebpchtxqrpfovocjaxdxpbppndqkqrpifcvwarxwbjjquupixvqarmuxblxsmxgsmbkwnvlsrcoqhtshioxjslqrixdecchpiffcnqceslepadsucqjkdnuuexujqjjidphsqcessejdomakhufmcbpqltripwuuexihwtdwlfipjwlwwsmwaaswhclbaxjllnhrhcuqunhirjukxsfqwsfnpgrvbvifijfgljcgevoigucvktjtcxpfcfutepatdkjqsgccvwhoaigqxhqgwpjgsqtdhpcemjegeshdogplxnqkwujrrrkjghxoetnblonqjnxcxvqndtxlhdfnsgdgokatcnkqirnprhkwqfsgvreddddrlgddsansrlreukdcfpkprunwdrgdagdflrtsckplrfbcfiaclwuvctatpbocpcxbchksgavhknsuuvufnmsrdsthpstqjrnoaajtwcqnucgrkpofbrmkfbpcnuggujnlfliglahwxtkjvpxjrfcqwamcxxplskirbjoktstbljjnpuocmalmxwbjhcnhrowpesmixxdoimiepamhbbpfbnxpmwidtlwfhgjgiaifwdcgmrqacrpusdvkfmswhtblqegwufkhwandibtwgitpmqueebaqnmokagcqnwadwrrmcwvqfosifwlmiqnjnxwrqcossktraxxikanwhsvwhmddbaxchtqaorkoctkskspaareiuotsjjeqpawkdknamkfdhxgfwcitmhbhmantswnlcrlcrsfabxasqhwksplrgenspbsbelpuslwrrmpimxksntdsiaxkwohkfblvgqreigwpdadqhretolvuxofxegivphioammckkdehgcrjgnntwtipjvhjtqflfamsrhwbwhbfwetkgwjmnfgxrotlxgksjmpmntbolxvoxruciwobqnxroqjdassfetqobikxbgaqkhorgonchakexvtcpfhkoogjnnboqcdvpbaxownhcbajvcroehjlxujtacpjqdflwnlerfwjrgqwicrjxxohowcneqlcqsoupdnqheiwtpseiknbxoqnndiqhxfakxxxrfqdasuabnotfneaomhhcmmcswgturhtwqeomibvlqflhbhnkibmgbevngndhbgcmpqpkfppbxgnvonqmsimjrkxixshswvttpmhlspmctrhawojedtxsvnckavrpbkwndahhhiwilhdiglabddndmovebxqecitrrnvgdsebihhfacnvjwochuixdxvkamcwjrlpgnwwrbnouoiggxsiopcrowoblilfexqmssdhpgefcmbfbdrviqnkbcmbulowcumleqnucfeqigistueafnqefohktfmbskwvhatmjwuirlvmebbtgjlnspqlphtvfaikjbvqmbwvldrftkredbwohxnnramekhrccteqnxbwppslaifedpchuvqqijimcwbulgwebhffewcxvctdxsnakjxmvqfwfniceteetksikihjpanjgcajbeebahvssugkuboijxiitwlbbtknjamrauvoiwgijuuvmivxtoanvpexqsrjqtpsauefgdkptmqcljxckpqpidukxnmdktssqjqejiqiinddstwrwlrvnlsdumkehbgrrfbmcuidxfowagimwrmjuookpidmbukbcxpmairqjghuwtpcdrpjemqxsihknefjeikgelnpwahvujcneeuonvarcvwagcraxpsqvfdhebpbbiidkrbxjsokbwaerffxcepemolcgloinjtnuqqonckiptvhjvbwgxjqjhowcwdjjdsltsabuoueumnbmdfnsbqulpcmraagfgvvhgarmveookrjsnbdxjvclhimkduvrkeshukwfxkgiehbvovsuhoiqfangoholaxdlvvqqmxtikixklbqkemqltlrecblwpoivhrhffbwxffutofgapiatbxgfostaarrknwctbcieeuqawruiqqibvwfacsnkjbwveuttaipqpxljlvjhawknbgogobctnehewlaedvtkhvefwcppojfgnbixdxktbtdxclsxbhwtdfnmwguasqiexfnsaevuhhdhinqdsawklrmpddjrfnmijudqvrkegwxurhebgpmqqacggxgdgxrccvtqlmtlwcxnucebgeanjcgqoutwnohjliftrgokqcsdjhjkcpkaohsodqxjssngtnraqqmasncfbudmiisrphehwfduodujkmgqorvghfnultkrshhcfkoewsiiqbvjrfwtfqiuubexxdowhmsaxaomthuvruwgoaxauxxrljhpglwwppdowbeqwmhcivhklncxuviwtvoehfdplaskigcafbtqnkkcaewsejmknfansqvjsphepvpllwghamvqugvwenlgarokquefnvrfdhcsvdrfsmsexrvwnancebinxbqtcqcncnuefimvcipwboqankbfjfglcpisdbqlwnvcknpvqkvfloemhtihivapgontiruqxrftuccovidruabdatkkqkopnoxvppwdtqdauauhqetletjnstxdrsxlwxwjcsvfubaijfxrjnldujdrerpnehmmbjsgrmkfswfeddbdaluqcjgxwgcvqhvkhnsvkuoutwqudacwovotbctbjtxgvecehbawhkhsbbbpqoujtvjlwgsnmgxwuuctbxsihfvglxkgcuwvfsmrlekdxbcfmrxwwfjlthsjkirqkrxcwmbmhevedcaufcxgvvnrshmkuuxwxpqxvloftwrxhdrtqxtkwfnhewfsetnijvrfkamuwsxglkmbmxtlshlqrctqhnafilctwrlqarpgabsprmxrqsnckmhfptlvvbskihckjbrjvplmxfwtaomfgeaqtlurxxdjjlljklnxkmhrhkrjdtqsndaktgnrxvdjxteospcpxqwgamavqjabapvtavmmudljuiwqjgrcntxktrtupqwbwjikrwsdojdlilbiaokqtnmvgkcraiidpkrqwtovvakujtewgrnicgdadxnkejxguiamitkdcwkojhbrtgscjofdcbtpklttevuhwnmnmmjrxrwbauaiqvsnjwvrsgebpipjadnctdqmeaeiunjxxebhsatavdrborhrgenkibhqxeltpqlrxrlrvnvlkadlixvxrimxkqonqfdvjnhgxorsqxstkodgvebeahswrxesqdtudmmoxjrsnvextogdfhcaubosgvkhfonaunuaamdsmwriphpjbikcmorrqubvkopkvinubvrkdecnnivrqhxdiottpdhuelscnvatswrbmghhotxslnskiburtsednvghuuffewfqwuqgrxgfritivimtvjkduukrcnmjnfdocwurwecjcjjngbcauihtjjqsaqmqacuegumawbtpgioqdnaqbpmmvcwhvwprkphrnoanaarxwgibfnmnlwjoxrftrfdfftgpueavmqtqjbqrdhpecgoipuvuvpjmagpdnhmlsrldhdgqnvqqwvdlovfkacrnmrdxhnefdupxjksgugjhqupgddpgsqtahkkdkhxlgxqfoamrhbqrxmukwnrieqggmkmghgogedfegutmoigxldqwavupfblxarqrfqjwlqifswifkctbnlllxcamnvksvaitmxisvxpaafduchhwecxagenwntlasvsnvkclsolmltucwhkpakdocllgddgqxcxhxqriahmcqpthoktdcsoffpbmcncdvnxastlsrqcbrbhklilljrjewqqxprbrdajbxcrivtmcnrrmmjsofbuuooahehbrrbxjuvllcheuvajmkfinorhmlrbviplehcxjeubdslaaxuhllvvifjrvpkkblkprocsaehspurrnnwdjjpaojruwkhvkwwejobaxwwxpjaxmxwufensqdbgaksqbqeudvpbfrjaniibvdfuakfmfsrikrjmncnvqvmelvifwbjbptjbjfblggsknxorhsxqxnikjttwnmtvtxeeqfpkspcljkxpxkmnrntuosttakooivuupqjakgsvnmwveksdwoviddolxcdepplteafunstocvsmxatunhpghuvxdnqpinqhxefxftlhxdkexwggxrhadhrxejwgjvkjrnqjhsuqfiiffllclcgmgebtragdvrtjkkwcvombmllxqqjikentrbecdkoecqchjtxshxnjtflsrmsalpcfeauojfakjtpdgblieoossfafpxfbxrpkgqinedsnjrsudscnfkxcktcbljknwmcsqkhileoulcltvamrkthkdxkwvdskpinubvtppociwocahdkmkbqbmkgmeelrclprbblcalqcloadxkkgnnjjothtbnwrjhqsshxqvchikrduvffgmosqqcnsludmblpesfpkwepkshekceuvhfdxlijkttlafiwkbgeafaicljepwqvlfbfgxubdasmhdvudixmchgkpwwjriisahsgftwhfdpqptcjghkiqhgvitpfjjejumixmahjaeuvaghoufoikdrrobsoxifmpvursvgbdcbvmmvjftdvhlwwjbbgkokcisfcjslgqveosudtracvqaofattudklkqsttxrxqvwxsbwcupvscnspmnwbptfqopghvnarptvbqcminbrdcoqlmgscbqpcfnnipshjkrrdqfdxuvvohktkwmagbkxahrpwqaxhdjlmsbohdmbcitssaxqghdgdefokcnimkjdewidwqwehepovuhbatrlkmhatukjxvcieeqcgvkwffpgtrmuwfwhvxqnbgpcjfeskeseojcbvsldkovaavaruoqomamfqcplagojxtmkhttnmvtgfmakaxxlnriiputaokmqanjebqwlifowfivbadudlundtmxtdjesbwbvnjffpowhqkjxudawxwrxgammhrnwlwlvkwavaalbxdsmfvlgiifdhskdsuifvvrfqpxidlunrbjpctnigsrqwirxninpxlbvivkrqhcloowbdlwpruugmerqxxmdjimmbwbwiuochqrrbxvbsxauhubpihfrmuslullhkcnltrjatwuwarldkkterkxsxalbpnjfprcwkqifjhrplmwssvngipuoksphmkdivcekfeubuevemwbsrvqoifseotnmdmjhgtkxlpomdeamsrutwcddggsvcuwbskkdsgfguqovwhbiflgmkeqwmrtjolsntdqthjvxiptfnvkhgwbfulfgjwhptkrcfrrahgcbiuptborclbdhexlmwnuxixtvrlgbkdtftxiqrcpixuvskacacwdsnmpqgbxpgkskkqplosecxpgvxokjvsmadiwdetusncfbdpuvgexansabckdqhxxabdagdbujwlvcinpwtrcrafbvdseuromlpvvpetaecncerqxfnslgrqsslpogkikawnfbgjafiilxnjvssflgwttajssnclcamvpkklmjqeknujbgeesksgeofjvssaeslvnkhjmldbfdogdrdvqjcrvfqgcfjaqhdtntfeibxxnuectkvcuuqvfurqhfhcgxlaqcecptowkfuebkucatdiwtiwosvvvbdefknuksiomrrlujpmsndmomwcvwctwgthgapdrweqkgijngxkdsbxovcdvwwdrvecrxsguwscwelvujllttedvwujofjngpnlinheskcnwmrpjtlxbqmhvamehrmbftoersvhnevsdwlpueqgxaccedlebkwpocadmhegdkcamrafetaideuwtwqbfripamcktueinurwtoabsbvvgefscrmlbwrbmqmamqwxdlsogellgvxoahkgbgodvirfkxheburcnpghhucliinranvkxswxdpidcasiapwjchfimousakphihvowimabfhudtndkseuddntfbkgvsvjgnlkuorpbxfopkavgvlmauqhefcqjaqnlgvosmucrqksmleggxthbcnuhugjsgxvplfkalndrwxbdoqgaqfogvfcitgxbjkhstdpndvqtjljmmvfnjqrhmwsffamvmsfdhwdlltdgcwegvkdvkerlxkshqohauwwmhwxiextjjbrdipjikculhbtvexxqmwjtstefnrqnvdpjouvnkjuxusfjkmwwkcabbwqsxkrspmarosqwsbxxfnjrjmtswdknlgfhssaiwvlljqlrbthsscfwlhgukqxjqlstvpugleahwgupxgtsvklqvohmlchtsfoiqlngwuheoffavssvuebprxobdacnxfdmmvdwwsquruudtaoupqbdxndmksqfxliajfxptqlfwdtsaxohhoctpnwvaikednflgmpawviifljtfxkgdhdqxrpmetwjtncpmjmtxrquhkwprqcqvlwscqxbocfgokpscnhhfvblmdcwvlwosakrgcmepvabuvmvrgotjaelmdvijhojuqxnuaxexfvlxeribokaclkofehemfcgdcvnlbrkvroumrxtbnuobmjckfitoldappekdvawsrjuwemobblmgndhrhioquhgofmeofgqfoqsdejqluweanopkqhksfhhtpgdkikpppcxlbptmfxeanurhsfktaemekipxwtuhuouxtmvhvnnfmuufntfemufsqtigqtqwggxhlkxcdahaswjhqhknjjsuaanxfbreebqkqhifxqsaasqclskvisdscfpjnnxagxjbcnkbsfvgfpbjwnnmxwhghewuipmcuaadbtdgsxsbrhdksollbhpowlkchpgepmhbwqmtkwhsecpnfxeklmdspmsabfplwlesbgvqxcnjxwodchhqhnlllfqrpbnkkghxaeohldenjmvuwfnwucxiqqkdxlrxjdsqncwffbtpluhxltgdllwlbubgmtkkfdmepihvnnuotglviisitijjlbfltcsmwpeupwhvmvfdttifgmruujjmqxfkwgxvcnlxlmpvbthnljxqmhkqoolehodsmjkmdhjofdhoevcnrsqokbpmchcbrwvuvjtcjlnifbgqonnthutoqkwxhvvbvxexcicoktrgrpgsocsovjqaxcicfwlhdbiusuojqwtauonvetpgriongcfmftnjtvjkfxbkkeevtuuirsfefipngieowfdqojwstijkjuufiltelouiqljpnvopitnltoqevxhbeatrjrkivpujdqnufcequelssvqplmdgtprbjqifmfuafxkmgnmrbkexeeedlpekwjnevhplkqovgisfgagrxmjaqvuspiuegwadxwfbwiiholtchcmrhbkvwhcjwprvsxsgoularfdwoigbbsfqadxphrudiemmlsdudlixrhxuvpltcsihkjqnkfdgwhnsiqdnvsoxqplwmbshejwfftejhkxchauwrbbcmrtxwdrgsmtgghxlkbeqwaqieqasoohtqqqajfhupjnhjmsqqereaxoqdvkliflpcafstloidjrleqbnqcivehabgbctwqwpbxsmuxgbhchjhtccqmudtiqevsikifplwwpwsphhkgxkcfwwckeumkeigsuhhwibhvdkhfqduljgownkwvxlpfvolxgtbsxmwnqvtacffdeuswpvclwoebknmlvgrjnslemsupvegfrnowuiaojwmxvgxfkxmckeemipuujrhriitmtkamqswfejwffwuxojletekgwlggjoqjvuihtscfqnatomqxrcidpkhvmdvoeggwkwkgribnjsohnjbkkobdsjcjsadqbjlbcxoalkcpxshrrugqcoqlfqlsblruhhjuuxsxrifjcllbtgxcjbmdahcjrefkhxpwsiqkltdfjfchdwmopaoktaamkcslbbohkphjrkdkvrvtjvgvmtncnqmetgvfnpvgvpqmcpfiggdvnduxhbrtakojwharkouvtwjdxxjpmvewohgnskclkmxmjocacbmlueformaopwjmornftirluwwlnstidodahcrnfwjhgqjrddiblrfdordikmedwvueoipronnsseulwspxrvhtpfhjqeepdhmxhvoathlndjlmojlrpfferjragblwjenklkgtlxlrrincfntglqjmsgjmndsgstgtroqdhdfoeikprrpwwxdvdtafwuqrumxttclwhmsnlsdkdtqaasjvurntobngirbdhnhgtjreagpdtdmgbifgvhqnifjnwqtrwafkdscerdgsbcgpjcxofwjflgngwjfgatejgbwwhcionqtlphvpwwbtweqbhnidnnufnduqckgrgufseqjqgoxvcqtoddtpfgofadeujmpdfpdnaukrohmexcvfafwjhaajphhjgxuctbfcdmrsfqoqnrwghqslnafbsxmhxeupnaecfaflfkqrmfwjhowunrcfiedvfkhcwxhvnpouemxalaoxsxcehjjfkwuvicfmnupmmcevexvtlhfowcotvijbbeqoxupdjasntqqwddrmunthfidbwhtrcpgiexeqdccspsjxjxdbgirtnbqgbonvqoptvmeedspbdxqiaduejqwapmokperoscshdcqobcpmwqdkorkduwsqkrmvijpsplpvocxvuiucxnmtfgiircgsaskpexvcqqgtotbtwufdhflndntcotrohmijkufxfjakkohhnxtgoioojdvbukddijhbeqhqoietdthjkjvfeaxqgdnnkgndljwiamrelkcmrjeieblhicosmtugcinfimvxxhnvdcdpujdovhnuerblrdjesawbgbvnrlssxvgcmkosunmegckfgvupdvvhgavbnfbkhwtpbveeaqpipaqxtgvxfpexbkvfnhrptddvkbgnktxghbubarfuipsbmpgaxjkideflapkdcmlhwvfdedthufpgkwpbeknfwcjtlgsxxldtlgdnrhxgiaeesiasmdqwvvimthgbtrxtprghvlckvbqmdursxugejeagakesewancixbjptmtxepwlljuemvpiebjggadbflutntvmsccdoddvfxeluckajnammnidomfsrgacqgcficcbqmxdfdjvbcddupdduxvubamqmxcmrlthsjvbprtplakuqqtkfgtbhcxhwuujsvnigeoqlcbvxappipkpeqaclnsoxpodscsmjwknqathoarlsuodwfuptpnogxrlrrikvaidgbbpprhaigagfuxpjcqodeeaqkqdbibaohtccecxrpahipqdvncpowblwvbwfqnmxrqtipsiwwnhifbsvpfjavodtkvmswuqrojhqmxsglrnepqfdkhlijnjxjknhmgumqgbcsqwjwkcmlgtwvbgxktvlkbiuicxjopphaxtparvislvxqkberdggnkojersiiubgaccrhwpbmolnluvxumfjcnohptmxgeahjklwurhosreiwvraunjsjcrgbqoiiqultxvwprwpcsbijxgicitllqgmkqikgruqwqasrhunfcrgeqegedcuwaolscbvaujbkxfbadqpmrnrqikkeoxtmsakribchucdhkmlontfwhustjqfadccdonkpibarqqqvcmjbvmaslhhgbqwsrcrvmnjmlbqpplxexwcddexshfcsshnrh";
//        String s = "leetcode";
//        System.out.println(s);
//        int pos = firstUniqChar(s);
//        System.out.println(pos);
//       String s = "anagram", t = "nagaram";
//       boolean result = isAnagram2(s,t);
//       System.out.println(result);
//        String s = "A man, a plan, a canal: Panama";
//        String s = "race a car";
//        String s = ".,";
//        String s = "a,";
//        String s = "P0";
//        String s = "42";
//        String s = "4193 with words";
//        String s = "-91283472332";
//        String s = "   -42";
//        String s = "   -";
//        String s = "   11";
//        String s = " ";
//        String s = " +4";
//        String s = "  0000000000012345678";
//        String s = "-000000000000001";
//        String s = "+000000000000001";
//        String s = "2147483646";
//        String s = "0-1";
//        String s = "0    123";
        String s = "1095502006p8";
//        String  haystack = "hello", needle = "ll";
//        String  haystack = "aaaaa", needle = "aaaaaa";
//        String  haystack = "", needle = "";
//        String  haystack = "a", needle = "a";
//        System.out.println(haystack);
//        System.out.println(needle);
//        int result = strStr(haystack,needle);
//        String result = countAndSay(30);
//        String[] strs = {"flower","flow","flight"};
//        String[] strs = {"dog","racecar","car"};
//        String[] strs = {"abc","ab",""};
//        String result = longestCommonPrefix(strs);
//        System.out.println(result);
//        int result = lengthOfLastWord("hello world");
//        int result = lengthOfLastWord("Today is a nice day");
//        PrintUtils.print(result);
        totalNQueens(4);
    }

    public String reverseString(String s) {
        int left = 0;
        int right = s.length() - 1;
        char tmp;
        char[] chars = s.toCharArray();
        while (left < right) {
            tmp = chars[left];
            chars[left] = chars[right];
            chars[right] = tmp;
            left++;
            right--;
        }
        return new String(chars);
    }

    private void printList(int[] nums) {
        for (int i = 0; i < nums.length; i++) {
            System.out.print(nums[i]);
            System.out.print(",");
        }
        System.out.println();
    }

    public int reverse(int x) {
        if (x == Integer.MIN_VALUE) {
            return 0;
        }

        boolean isNegative = x < 0 ? true : false;
        if (isNegative) {
            x = -1 * x;
        }
        int[] retArray = new int[10];
        int actualSize = 0;
        while (x >= 1) {
            int oneValue = x % 10;
            retArray[actualSize] = oneValue;
            actualSize++;
//            ret = ret *10 + oneValue;
            x /= 10;
        }

        int[] max = new int[]{2, 1, 4, 7, 4, 8, 3, 6, 4, 7};
        int[] maxNegative = new int[]{2, 1, 4, 7, 4, 8, 3, 6, 4, 8};

        if (isNegative) {

            if (actualSize > maxNegative.length) {
                return 0;
            }
            if (actualSize == maxNegative.length) {
                for (int i = 0; i < actualSize; i++) {
                    if (retArray[i] < maxNegative[i]) {
                        break;
                    }
                    if (retArray[i] > maxNegative[i]) {
                        return 0;
                    }
                }

            }

            int ret = 0;
            for (int i = 0; i < actualSize; i++) {
                int thisValue = -1 * retArray[i];
                ret = ret * 10 + thisValue;
            }
            return ret;

        } else {
            if (actualSize > max.length) {
                return 0;
            }
            if (actualSize == max.length) {
                for (int i = 0; i < actualSize; i++) {
                    if (retArray[i] < maxNegative[i]) {
                        break;
                    }
                    if (retArray[i] > max[i]) {
                        return 0;
                    }
                }
            }

            int ret = 0;
            for (int i = 0; i < actualSize; i++) {
                int thisValue = retArray[i];
                ret = ret * 10 + thisValue;
            }
            return ret;
        }

    }


    public int firstUniqChar(String s) {
        if (s.length() == 1) {
            return 0;
        }

        int ret = -1;
        for (int i = 'a'; i <= 'z'; i++) {
            int count = 0;
            int firstFind = -1;
            for (int j = 0; j < s.length(); j++) {
                if (i == s.charAt(j)) {
                    count++;
                    if (firstFind == -1) {
                        firstFind = j;
                    }
                }
            }
            if (count == 1 && (firstFind < ret || ret == -1)) {
                ret = firstFind;
            }
        }
        return ret;

    }

    public int firstUniqChar2(String s) {
        int size = s.length();
        int[] buckets = new int[size];
        int[] index = new int[size];
        int[] values = new int[size];
        int actualSize = 0;
        for (int i = 0; i < s.length(); i++) {
            boolean find = false;
            for (int j = 0; j < actualSize; j++) {
                if (s.charAt(i) == values[j]) {
                    find = true;
                    buckets[j] = buckets[j] + 1;
                    break;
                }
            }
            if (!find) {
                buckets[actualSize] = buckets[actualSize] + 1;
                values[actualSize] = s.charAt(i);
                index[actualSize] = i;
                actualSize++;
            }
        }

        for (int i = 0; i < actualSize; i++) {
            if (buckets[i] == 1) {
                return index[i];
            }
        }

        return -1;
    }


    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }
        for (int i = 'a'; i <= 'z'; i++) {
            int countA = 0;
            int countB = 0;
            for (int j = 0; j < s.length(); j++) {
                if (i == s.charAt(j)) {
                    countA++;
                }
                if (i == t.charAt(j)) {
                    countB++;
                }
            }
            if (countA != countB) {
                return false;
            }
        }

        return true;
    }

    public boolean isAnagram2(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }

        int alphaSize = 'z' - 'a' + 1;
        int[] bucketsA = new int[alphaSize];
        int[] bucketsB = new int[alphaSize];
        for (int i = 0; i < t.length(); i++) {
            bucketsA[s.charAt(i) - 'a'] = bucketsA[s.charAt(i) - 'a'] + 1;
            bucketsB[t.charAt(i) - 'a'] = bucketsB[t.charAt(i) - 'a'] + 1;
        }
        for (int i = 0; i < alphaSize; i++) {
            if (bucketsA[i] != bucketsB[i]) {
                return false;
            }
        }

        return true;
    }


    public boolean isPalindrome(String s) {
        s = s.toLowerCase();
        char[] chars = s.toCharArray();
        char[] clearChars = new char[s.length()];
        int usefulIndex = 0;
        for (int i = 0; i < chars.length; i++) {
            char value = chars[i];
            if ((value >= 'a' && value <= 'z') || (value >= '0' && value <= '9')) {
                clearChars[usefulIndex] = chars[i];
                usefulIndex++;
            }
        }

        if (usefulIndex <= 1) {
            return true;
        }
        int left = 0;
        int right = usefulIndex - 1;
        while (left < right) {
            if (clearChars[left] != clearChars[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }


    public boolean isPalindrome2(String s) {
        int left = 0;
        int right = s.length() - 1;
        char[] charS = s.toCharArray();
        while (left < right) {
            char rightVale = charS[right];
            if (!(rightVale >= 'a' && rightVale <= 'z') && !(rightVale >= 'A' && rightVale <= 'Z') && !(rightVale >= '0' && rightVale <= '9')) {
                right--;
                continue;
            }
            if (rightVale >= 'A' && rightVale <= 'Z') {
                rightVale += 32;
            }

            char leftValue = charS[left];
            if (!(leftValue >= 'a' && leftValue <= 'z') && !(leftValue >= 'A' && leftValue <= 'Z') && !(leftValue >= '0' && leftValue <= '9')) {
                left++;
                continue;
            }
            if (leftValue >= 'A' && leftValue <= 'Z') {
                leftValue += 32;
            }

            if (leftValue == rightVale) {
                left++;
                right--;
                continue;
            } else {
                return false;
            }
        }
        return true;
    }


    public int myAtoi(String str) {
        char[] array = str.toCharArray();
        if (array.length == 0) {
            return 0;
        }
        int[] max = new int[]{2, 1, 4, 7, 4, 8, 3, 6, 4, 7};
        int[] maxNegative = new int[]{2, 1, 4, 7, 4, 8, 3, 6, 4, 8};

        int firstPos = 0;
        char firstValue = array[firstPos];
        boolean preHaveZero = false;
        while (firstValue == ' ' || firstValue == '0') {
            firstPos++;
            if (preHaveZero && firstValue == ' ') {
                return 0;
            }
            if (firstValue == '0') {
                preHaveZero = true;
            }
            if (firstPos < str.length()) {
                firstValue = array[firstPos];
            } else {
                break;
            }
        }

        if (firstValue == '-' && !preHaveZero) {
            int actualSize = 0;
            char[] actualArray = new char[array.length - 1];
            for (int i = firstPos + 1; i < array.length; i++) {
                if (actualSize == 0) {
                    if (array[i] >= '1' && array[i] <= '9') {
                        actualArray[actualSize] = array[i];
                        actualSize++;
                    } else if (array[i] == '0') {
                        continue;
                    } else {
                        break;
                    }
                } else {
                    if (array[i] >= '0' && array[i] <= '9') {
                        actualArray[actualSize] = array[i];
                        actualSize++;
                    } else {
                        break;
                    }
                }

            }
            if (actualSize > maxNegative.length) {
                return Integer.MIN_VALUE;
            } else if (actualSize < maxNegative.length) {
                int value = 0;
                for (int i = 0; i < actualSize; i++) {
                    value = value * 10 + actualArray[i] - 48;
                }
                return value * -1;
            } else {
                boolean isOut = false;
                for (int i = 0; i < actualSize; i++) {
                    if (actualArray[i] - 48 == maxNegative[i]) {
                        continue;
                    } else if (actualArray[i] - 48 < maxNegative[i]) {
                        break;
                    } else if (actualArray[i] - 48 > maxNegative[i]) {
                        isOut = true;
                    }
                }
                if (isOut) {
                    return Integer.MIN_VALUE;
                }

                int value = 0;
                for (int i = 0; i < actualSize; i++) {
                    value = value * 10 + actualArray[i] - 48;
                }
                return value * -1;
            }
        } else if (firstValue == '+' && !preHaveZero) {
            int actualSize = 0;
            char[] actualArray = new char[array.length];
            for (int i = firstPos + 1; i < array.length; i++) {
                if (actualSize == 0) {
                    if (array[i] >= '1' && array[i] <= '9') {
                        actualArray[actualSize] = array[i];
                        actualSize++;
                    } else if (array[i] == '0') {
                        continue;
                    } else {
                        break;
                    }
                } else {
                    if (array[i] >= '0' && array[i] <= '9') {
                        actualArray[actualSize] = array[i];
                        actualSize++;
                    } else {
                        break;
                    }
                }
            }
            if (actualSize > max.length) {
                return Integer.MAX_VALUE;
            } else if (actualSize < max.length) {
                int value = 0;
                for (int i = 0; i < actualSize; i++) {
                    value = value * 10 + actualArray[i] - 48;
                }
                return value;
            } else {
                boolean isOut = false;
                for (int i = 0; i < actualSize; i++) {
                    if (actualArray[i] - 48 == max[i]) {
                        continue;
                    } else if (actualArray[i] - 48 < max[i]) {
                        break;
                    } else if (actualArray[i] - 48 > max[i]) {
                        isOut = true;
                    }
                }
                if (isOut) {
                    return Integer.MAX_VALUE;
                }

                int value = 0;
                for (int i = 0; i < actualSize; i++) {
                    value = value * 10 + actualArray[i] - 48;
                }
                return value;
            }
        } else if (firstValue >= '0' && firstValue <= '9') {
            int actualSize = 0;
            char[] actualArray = new char[array.length];
            for (int i = firstPos; i < array.length; i++) {
                if (actualSize == 0) {
                    if (array[i] >= '1' && array[i] <= '9') {
                        actualArray[actualSize] = array[i];
                        actualSize++;
                    } else if (array[i] == '0') {
                        continue;
                    } else {
                        break;
                    }
                } else {
                    if (array[i] >= '0' && array[i] <= '9') {
                        actualArray[actualSize] = array[i];
                        actualSize++;
                    } else {
                        break;
                    }
                }
            }
            if (actualSize > max.length) {
                return Integer.MAX_VALUE;
            } else if (actualSize < max.length) {
                int value = 0;
                for (int i = 0; i < actualSize; i++) {
                    value = value * 10 + actualArray[i] - 48;
                }
                return value;
            } else {
                boolean isOut = false;
                for (int i = 0; i < actualSize; i++) {
                    if (actualArray[i] - 48 == max[i]) {
                        continue;
                    } else if (actualArray[i] - 48 < max[i]) {
                        break;
                    } else if (actualArray[i] - 48 > max[i]) {
                        isOut = true;
                    }
                }
                if (isOut) {
                    return Integer.MAX_VALUE;
                }

                int value = 0;
                for (int i = 0; i < actualSize; i++) {
                    value = value * 10 + actualArray[i] - 48;
                }
                return value;
            }
        } else {
            return 0;
        }
    }


    public int strStr(String haystack, String needle) {
        if (needle.length() == 0) {
            return 0;
        }
        if (haystack.length() == 0) {
            return -1;
        }
        if (haystack.length() < needle.length()) {
            return -1;
        }


        for (int i = 0; i < haystack.length(); i++) {
            if (i + needle.length() > haystack.length()){
                break;
            }
            boolean isSame = true;
            for (int j = 0; j < needle.length(); j++) {
                if (i + j >= haystack.length()){
                    isSame = false;
                    break;
                }
                if (haystack.charAt(i+j) == needle.charAt(j)) {
                    continue;
                }else {
                    isSame = false;
                    break;
                }
            }
            if (isSame){
                return i;
            }
        }
        return -1;
    }


    //111122222
    public String countAndSay(int n) {

        int[][] rows = new int[30][10000];
        int[] rowsSize = new int[30];
        rows[0] = new int[600];
        rows[0][0] = 1;
        rowsSize[0] = 1;
        for (int i = 1; i < n ; i++){
            int[] currentRow = rows[i];
            int currentRowSize  = 0;
            int[] preRow = rows[i-1];
            int preRowSize = rowsSize[i-1];
            int index  = 0 ;
            int count = 0;
            while ( index< preRowSize){
                count++;
                if (index+1 >= preRowSize || preRow[index] != preRow[index+1]){
                    currentRow[currentRowSize++] = count;
                    currentRow[currentRowSize++] = preRow[index];
                    count=0;
                }
                index++;
            }
            rowsSize[i] = currentRowSize;
            printList(currentRow);
        }
        int[] rowResult = rows[n-1];
        StringBuilder sb = new StringBuilder();
        for (int i = 0 ; i < rowsSize[n-1] ; i++){
            sb.append(rowResult[i]);
        }
        return sb.toString();
    }



    public String longestCommonPrefix(String[] strs) {
        if (strs.length == 0){
            return "";
        }

        if (strs.length == 1){
            return strs[0];
        }

        int minPos = 0;
        for (int i = 0 ; i < strs.length ; i++){
            if (strs[minPos].length() > strs[i].length()){
                minPos = i;
            }
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0 ; i < strs[minPos].length() ; i++){
            char v = strs[minPos].charAt(i);
            for (int j = 0 ; j < strs.length ; j++){
                if (v != strs[j].charAt(i)){
                    return sb.toString();
                }
            }
            sb.append(v);
        }

        return sb.toString();
    }


    public int lengthOfLastWord(String s) {
        int count= 0;
        int lastCount = 0;
        for (int i = 0 ; i < s.length() ; i++){
            char item = s.charAt(i);
            if (item == ' '){
                if (count != 0){
                    lastCount = count;
                }
                count = 0;
            }else {
                count++;
            }
        }
        if (count != 0){
            lastCount = count;
        }
        return lastCount;
    }



    public List<List<String>> solveNQueens(int n) {
        List<List<String>> result = new ArrayList<>();
        List<Integer> queues = new ArrayList<>();
        List<List<Integer>> queueList = new ArrayList<>();
        solve(n,0,queues,queueList);

        for (int i = 0 ; i < queueList.size() ; i ++){
            List<String> oneResult = new ArrayList<>();
            for (int j = 0 ; j < queueList.get(i).size() ; j++){
                int position = queueList.get(i).get(j);
                StringBuilder strResult = new StringBuilder();
                for (int p = 0 ;  p < n ; p++){
                    if (position == p){
                        strResult.append("Q");
                    }else {
                        strResult.append(".");
                    }
                }
                oneResult.add(strResult.toString());
            }
            result.add(oneResult);
        }
        PrintUtils.print(result);
        return result;
    }

    private void solve(int n ,int currentRow,List<Integer> queues,List<List<Integer>> queuesList){
        if (currentRow == n-1){
            for (int column = 0 ; column < n ; column++){
                int testRow = currentRow;
                int testColumn = column;
                queues.add(testColumn);
                if (isQueueValid(queues,testRow,testColumn)){
                    queuesList.add(new ArrayList<Integer>(queues));
                }
                queues.remove(queues.size()-1);
            }
        }
        for (int column = 0 ; column < n ; column++){
            int testRow = currentRow;
            int testColumn = column;
            queues.add(testColumn);
            if (isQueueValid(queues,testRow,testColumn)){
                solve(n,currentRow+1,queues,queuesList);
            }
            queues.remove(queues.size()-1);
        }
    }



    public int totalNQueens(int n) {

        List<Integer> queues = new ArrayList<>();
//        List<List<Integer>> queueList = new ArrayList<>();
        Integer[] count = {0};
        solve2(n,0,queues,count);
        PrintUtils.print(count[0]);
        return count[0];
    }

    private void solve2(int n ,int currentRow,List<Integer> queues,Integer[] count){
        if (currentRow == n-1){
            for (int column = 0 ; column < n ; column++){
                int testRow = currentRow;
                int testColumn = column;
                queues.add(testColumn);
                if (isQueueValid(queues,testRow,testColumn)){
                    count[0]+=1;
                }
                queues.remove(queues.size()-1);
            }
            return;
        }
        for (int column = 0 ; column < n ; column++){
            int testRow = currentRow;
            int testColumn = column;
            queues.add(testColumn);
            if (isQueueValid(queues,testRow,testColumn)){
                solve2(n,currentRow+1,queues,count);
            }
            queues.remove(queues.size()-1);
        }
    }

    private boolean isQueueValid(List<Integer> queue,int row,int column){
        if (row == 0){
            return true;
        }
        for (int i = 0 ; i < row ; i ++){
            int oneRow = i;
            int oneColumn = queue.get(i);
            if (oneRow == row){
                return false;
            }
            if (oneColumn == column){
                return false;
            }
            if ((row - oneRow) == (column - oneColumn)){
                return false;
            }
            if (row+column == oneColumn + oneRow){
                return false;
            }
        }
        return true;
    }
}
